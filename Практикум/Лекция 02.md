## Лекция 2
`10 сентября 2021`

### Структуры и арифметика

**Структурный терм** – терм вида `<name>(..., ..., ...)`. Например, `point(5, 7)`. Выглядит это как предикат, но предикат не может передаваться в качестве аргумента (свойство языка), поэтому можно воспринимать это как структуру. 

Арифметические операции также являются структурами: `2 + 3 <=> +(2, 3)`.

Какие-то объекты языка могут быть *унифицированы* (сопоставлены), какие-то нет:
- `const -> const` – всегда
- `const -> переменнная` – всегда
- `структура -> переменная` – всегда
- `структура -> структура` – если одинаковые имена и количество переменных
    Например, `2 + 3` и `3 + 2` не будут унифицированы, потому что первая структура выглядит как `+(2, 3)`, а вторая – `+(3, 2)` (разные имена переменных).

Для сравнения есть встроенные предикаты:
- `=:=` – равно
- `=/=` – не равно
- `>=` – больше или равно
- `=<` – меньше или равно
- `<` – меньше
- `>` – больше
- `is(X, Y)`, `X is Y` – второй аргумент вычисляется, а затем унифицируется со вторым

Примеры:
```prolog
?- 5 is 2 + 3.
true.

?- 7 is 2 + 4.
false.

?- X is 3 * 8.
X = 24.

?- 2 + 3 is 2 + 3.
false.

?- X = 2 + 3, 5 is X.
X = 2+3.

?- x = 2 + 3, 5 is x.
false.

?- Y = 2 + 3, X =:= Y.
ERROR: ...

?- Y = 2 + 3, X is Y.
Y = 2+3,
X = 5.
```

Рассмотрим на примере деревьев. Пусть
- `nil` – пустое дерево
- `tree(метка, левое поддерево, правое поддерево)` – дерево

**Пример.** `sumTree` – вычисление суммы меток дерева.

**Решение:**
```prolog
sumTree(0, nil).
sumTree(Sum, tree(V, L, R)) :- 
    sumTree(SumLeft, L), 
    sumTree(SumRight, R), 
    Sum is SumLeft + SumRight + V.
```
Работает так:
```prolog
?- sumTree(N, tree(1, tree(2, nil, nil), tree(3, nil, nil))).
N = 6.

?- sumTree(6, tree(1, tree(2, nil, nil), tree(3, nil, nil))).
true.
```

**Пример.** `treeDepth` – вычисление глубины дерева.

**Решение:**
```prolog
treeDepth(0, nil).
treeDepth(D, tree(V, L, R)) :-
    treeDepth(DepthLeft, L),
    treeDepth(DepthRight, R),
    D is 1 + max(DepthLeft, DepthRight).
```

**Пример.** `subTree` – проверка на то, является ли первый аргумент поддеревом второго. Если первый аргумент – переменная, доолжен происходить перребор всех поддеревьев, причем пустые поддерревья выводить не надо.

**Решение:**
```prolog
subTree(tree(A, B, C), tree(A, B, C)).
subTree(T, tree(V, L, R)) :- 
    subTree(T, L);
    subTree(T, R).
```
Работает так:
```prolog
?- subTree(tree(4, nil, nil), tree(1, tree(2, nil, nil), tree(3, tree(4, nil, nil), nil))).
true.

?- subTree(X, tree(1, tree(2, nil, nil), tree(3, tree(4, nil, nil), nil))).
X = tree(1, tree(2, nil, nil), tree(3, tree(4, nil, nil), nil)) ;
X = tree(2, nil, nil) ;
X = tree(3, tree(4, nil, nil), nil) ;
X = tree(4, nil, nil) ;
false.
```
